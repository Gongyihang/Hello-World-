<!-- GFM-TOC -->
* [2019年3月](#2019年3月)
    * [11.Monday.Sunny](#11.Monday.Sunny)
<!-- GFM-TOC -->


# 2020年7月

## 11.Monday.Sunny
1. Linux和Windows一样，没有孰高孰低之分，只是两种不同的操作系统而已。    
2. 图形化界面之于命令行，是人们对更高级、更方便的工具的追求的必然结果。
3. Linux C++ 也不一定就是后台开发，Windows C++ 也不一定就是客户端开发；所谓的服务器与客户端是个相对的概念，即谁给谁提供服务，提供服务的我们认为是服务端（后台），被服务的我们认为是客户端（前台）。
  
## UNIX 与 Linux [Linux与Unix之差异在哪？](https://baijiahao.baidu.com/s?id=1591814171811153796&wfr=spider&for=pc)  
在计算机时代，相当一部分的人错误地认为 Unix 和 Linux 操作系统是一样的。然而，事实恰好相反。让我们仔细看看。
#### 什么是 Unix?
在 IT 领域，以操作系统而为人所知的 Unix，是 1969 年 AT&T 公司在美国新泽西所开发的(目前它的商标权由国际开放标准组织所拥有)。大多数的操作系统都受到了 Unix 的启发，而 Unix 也受到了未完成的 Multics 系统的启发。Unix 的另一版本是来自贝尔实验室的 Play 9。
#### Unix 被用于哪里?
作为一个操作系统，Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。
#### Unix 系统的特点
1. 支持多任务
2. 相比 Multics 操作更加简单
3. 所有数据以纯文本形式存储
4. 采用单一根文件的树状存储
5. 能够同时访问多用户账户  
#### Unix 操作系统的组成
a) 单核操作系统，负责低级操作以及由用户发起的操作，内核之间的通信通过系统调用进行。
b) 系统工具
c) 其他应用程序
#### 什么是 Linux?
这是一个基于 Unix 操作系统原理的开源操作系统。正如开源的含义一样，它是一个可以自由下载的系统。它也可以通过编辑、添加及扩充其源代码而定制该系统。这是它最大的好处之一，而不像今天的其它操作系统(Windows、Mac OS X 等)需要付费。Unix 系统不是创建新系统的唯一模版，另外一个重要的因素是 MINIX 系统，不像 Linus，此版本被其缔造者(Andrew Tanenbaum)用于商业系统。
Linux 由 Linus Torvalds 开发于 1991 年，这是一个其作为个人兴趣的操作系统。为什么 Linux 借鉴 Unix 的一个主要原因是因为其简洁性。Linux 第一个官方版本(0.01)发布于 1991 年 9 月 17 日。虽然这个系统并不是很完美和完善，但 Linus 对它产生很大的兴趣，并在几天内，Linus 发出了一些关于 Linux 源代码扩展以及其他想法的电子邮件。
#### Linux 的特点
Linux 的基石是 Unix 内核，其基于 Unix 的基本特点以及 POSIX 和单独的 UNIX 规范标准。看起来，该操作系统官方名字取自于 Linus，其中其操作系统名称的尾部的 “x” 和 Unix 系统相联系。
#### 主要功能
1. 同时运行多任务(多任务)
2. 程序可以包含一个或多个进程(多用途系统)，且每个进程可能有一个或多个线程。
3. 多用户，因此它可以运行多个用户程序。
4. 个人帐户受适当授权的保护。
5. 因此账户准确地定义了系统控制权。  
企鹅 Tux 的 Logo 作者是 Larry Ewing，他选择这个企鹅作为他的开源 Linux 操作系统的吉祥物。Linux Torvalds 最初提出这个新的操作系统的名字为 “Freax” ，即为 “自由(free)” + “奇异(freak)” + x(UNIX 系统)的结合字，而不像存放它的首个版本的 FTP 服务器上所起的名字(Linux)。  


#### UNIX和Linux的授权方式不同
从根本上讲，UNIX和Linux最大的区别在于前者是对源代码实行知识产权保护的传统商业软件。在UNIX发展初期，当时的UNIX版权归AT&T公司所有。为了促进UNIX的发展，AT&T公司以低廉甚至免费的许可将UNIX源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩充和改进，形成了所谓的UNIX衍生版，这些衍生版反过来也促进了UNIX的发展。  

后来AT&T公司意识到了UNIX的商业价值，不再将UNIX源码授权给学术机构，并对之前的UNIX及其变种声明了版权权利。这对UNIX的发展产生了很大的影响。在随后的几十年中，UNIX的发展经常伴随着产权纠纷。对于UNIX来说，应用比较广泛的发行版大多数都是商业公司来维护，例如OracleSolaris、IBMAIX以及HPUX等。  

Linux从一开始就是遵循GNU通用公共许可协议(GNU General Publice License，简称GNU GPL或GPL)，GPL授予程序接受人以任何目的运行此程序的自由、再发行复制件的自由以及改进程序、并公开发布改进的自由。因此，任何个人或者公司都可以在GPL的允许范围之内对Linux的代码进行修改，并且进行再发行。另外，Linux可以运用于任何的领域，包括商业应用。  

#### UNIX和Linux不存在技术上面的传承关系  

尽管Linux的设计思想受到了MINIX的很大影响，但是这种影响并不是技术上的，更多的是理念上的。Linux并没有使用UNIX的一行代码，是Linux完全从头构建的操作系统。因此，Linux不是UNIX的衍生版，它是一个全新的操作系统。   

#### UNIX和Linux对于硬件的要求不同  

由于长期以来，UNIX都是由一些大型的公司在维护，因此UNIX通常与这些公司所生产的硬件相配套。例如，Oracle Solaris在很长的一段时间都只有SPARC平台的版本，HP-UX可以在HP的PA-RISC处理器、Intel的Itanium处理器的电脑上运行、IBMAlX则运行在IBM的Power PC架构之上。正因为如此，很大程度上限制了UNIX的广泛应用。  

#### UNIX是一个功能非常全面的操作系统，在某些方面超越Linux
经过30多年的不断发展，UNIX的一些基本技术已变得十分成熟，有的已成为各类操作系统的常用技术。无数的实践表明，UNIX是能达到大型主机可靠性要求的少数操作系统之一。目前许多UNIX大型：主机和服务器在国内外的大型企业中每天24小时不间断地运行。例如，不少大企业或政府部门，将其整个企业/部门信息系统建立并运行在以UNIX为主服务器的客户机/服务器架构上。  

Linux成功地模仿了UNIX系统和功能，它能够在普通PC计算机上实现全部的UNIX特性，具有多任务、多用户的能力。更为重要的是，Linux是一个开放源代码的产品，任何个人或者公司都可以修改Linux内核的源代码，实现或者增强自己想要的功能。  

实际上，UNIX与Linux的区别还有很多，例如，UNIX拥有强大的网络功能，作为互联网基石的TCP/IP协议就是在UNIX系统上开发和发展起来的。UNIX多用于超级计算机、小型机或者工作站，这些技术的成长与UNIX是分不开的。UNIX是历史上影响最大、最成功的操作系统。  

#### 联系
Linux的起源可以追溯到古老的UNIX系统。正因为受到了UNIX的影响，才诞生了Linux。Linux继承了UNIX的许多优良传统，例如强大的网络功能、完善的命令以及良好的健壮性与稳定性。无论是从外观上，还是从功能上，UNIX与Linux都是非常相似的。例如，UNIX的大部分常用命令都可以在Linux中找到相应的命令。  

另外，Linux同样是一个遵循POSIX标准的操作系统。因此，许多UNIX上面的应用可以非常方便地移植到Linux上面。同样，Linux上面的应用也可以非常方便地转移到UNIX上面。  



#### 操作系统
1. 操作系统结构
2. 中断及系统调用
3. 内存管理
4. 进程和线程
5. 处理机调度
6. 同步互斥
7. 文件系统
8. I/O子系统

#### 什么是操作系统？
没有公认的精确的定义  
操作系统是一个控制程序  
操作系统是一个资源管理器  
应用程序与硬件之间的中间层  
管理各种计算机软硬件资源  
提供访问计算机软硬件资源的高效手段  
解决资源访问冲突，确保资源公平使用  

操作系统内核：系统调用接口、硬件抽象层  
内核的特征：并发、共享、虚拟、异步  
并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度  
共享：宏观上“同时”访问，微观上互斥共享  
虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务  
异步：  
1. 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知  
2. 只要运行环境相同，OS需要保证程序运行的结果也要相同  

操作系统的结构：  
分层结构、微内核结构（尽可能将内核功能移到用户空间）、外核结构（虚拟机管理器VMM）  
我们现在用的是分层和微内核的混合体  


#### x86的中断处理  
中断：  
外部中断（串口、硬盘、网卡、时钟）硬中断  
软件产生的中断（软中断）（用户程序通过系统调用访问OS内核服务） 

异常：  
除0错误  

每个中断或者异常与一个中断服务例程关联，其中断关系存储在中断描述表中  
（ISR，Interrupt Service Routian）  

#### 操作系统实验
http://os.cs.tsinghua.edu.cn/oscourse/OS2020spring  

#### 操作系统的内存管理方式   
希望内存管理抽象（逻辑地址空间）、保护（独立地址空间）、共享（访问相同内存）、虚拟化（更大的地址空间）
操作系统中采用的内存管理方式：  
1. 重定位(段地址+偏移量)  
2. 分段（数据段、代码段、堆栈三个相对独立的部分）    
3. 分页（）  
4. 虚拟存储（目前多数系统如Linux采用按需页式虚拟存储）  

实现高度依赖硬件  
1. 与计算机存储架构紧耦合  
2. MMU（内存管理单元）：处理CPU存储访问请求的硬件  


#### 地址空间 & 地址生成  
地址的定义：物理地址空间、逻辑地址空间  
逻辑地址的生成：编译、汇编、链接、程序加载（重定位）  
地址生成时机和限制：  
编译时（1.假设起始地址已知  2.如果起始地址改变，必须重新编译）  
加载时（1.如编译时起始位置未知，编译器需生成可重定位的代码  2.加载时，生成绝对地址）  
执行时（1.执行时代码可移动  2.需地址转换（映射）硬件支持）  

#### 连续内存分配  
内存碎片  
动态分配：  
1. 最先匹配  
原理：分配n个字节，使用第一个可用的空间比n大的空闲块。  
空闲分区列表按地址顺序排序。  
分配过程时，搜索一个合适的分区。  
释放分区时，检查是否可与临近的空闲分区合并  
优点：简单、在高地址空间有大块的空闲分区  
缺点：外部碎片、分配大块时较慢  

2. 最佳匹配  
原理：分配n字节分区时，查找并使用不小于n的最小空闲分区。比它大的最少的  
空闲分区列表按大小排序  
分配时，查找一个合适的分区  
释放时，查找并且合并临近的空闲分区（如果没有找到）  
优点：大部分分配的尺寸较小时，效果很好（可避免大的空闲分区被拆分，可减少外部碎片的大小，相对简单）  
缺点：外部碎片、释放分区较慢、容易产生很多无用的小碎片  

3. 最差匹配  
碎片整理  
原理：分配n字节，使用尺寸不同小于n的最大空闲分区  
空闲分区列表按大到小排序  
分配时，选最大的分区  
释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序  
优点：中等大小的分配较多时，效果最好。避免出现太多的小碎片。  
缺点：释放分区较慢、外部碎片、容易破坏大的空闲分区，因此后续难以分配大的分区  


连续内存分配  
给进程分配一块不小于指定大小的连续的物理内存区域  
内存碎片  
空闲内存不能被利用  
外部碎片  
分配单元之间未被使用的内存  
内部碎片  
分配单元内部的未被使用的内存  
取决于分配单元大小是否要取整  

（分配空闲分区按什么排序、分配时的查找开销、释放时的合并开销、合并后放回到空闲分区列表找合适位置的开销）

碎片整理：通过调整进程占用的分区位置来减少或避免分区碎片  
紧凑：通过移动分配给进程的内存分区，以合并外部碎片（条件：所有的应用程序可动态重定位，需要解决的问题：什么时候移动？开销？）    
分区对换：通过抢占并回收处于等待状态进程的分区，以增大可用内存空间。（换入换出的开销很大）  

#### 实例：伙伴系统
二分法  
大了切一半  
释放后，连续的内存地址能合并成2的幂则合并  

#### 非连续内存分配  


#### 段式存储管理  
进程的段地址空间由多个段组成  
主代码段  
子模块代码段  
公用库代码段  
堆栈段  
堆数据  
初始化数据段  
符号表  
等  

#### 页式存储管理  
页帧（物理页面）：把物理地址空间划分为大小相同的基本分配单位（2的n次方，如512,4096,8192）  
内存物理地址的表示：二元组（f,o），f——帧号（F位，共有2的F次方个帧），o——帧内偏移（S位，每帧有2的S次方字节）  
物理地址 = f * 2^S + o  

页面（逻辑页面）：把逻辑地址空间也划分为相同大小的基本分配单位（帧和页的大小必须是相同的）  
页内偏移 = 帧内偏移  
通常：页号大小 ≠ 帧号大小  


页面到页帧：  
1. 逻辑地址到物理地址的转换  
2. 页表（保存了逻辑地址到物理地址之间的映射关系）  
3. MMU/TLB  

##### 页表  
每个进程都有一个页表  
1. 每个页面对应一个页表项  
2. 随进程运行状态而动态变化  
3. 页表基址寄存器（PTBR:Page Table Base Register）  

页式存储管理机制的性能问题  
1. 访问一个内存单元需要2次内存访问  
2. 第一次访问：获取页表项  
3. 第二次访问：访问数据  

页表大小问题：  
1. 页表可能非常大  
2. 64位机器如果每页1024个字节，那么一个页表的大小会是多大？  

如何处理？  
1. 缓存（快表，TLB）  
2. 间接访问（多级页表，建立页表“树”，减少每级页表的长度）（反置页表，将进程的ID也考虑进去做hash）  

大地址空间问题  
对于大地址空间（64-bits）系统，多级页表变得繁琐  
比如：5级页表  
逻辑（虚拟）地址空间增长速度快于物理地址空间  

页寄存器和反置业面的思路  
1. 不让页表与逻辑地址空间的大小相对应  
2. 让页表与物理地址空间的大小相对应  

页寄存器中的地址转换  
CPU生成的逻辑地址如何找到对应的物理地址？  
对逻辑地址进行hash映射，以减少搜索范围  
需要解决可能的冲突  

用快表缓存页表项后的页寄存器搜索步骤  
1. 对逻辑地址进行hash变换
2. 在快表中查找对应页表项  
3. 有冲突时遍历冲突项链表  
4. 查找失败时，产生异常  

快表的限制：  
1. 快表的容量限制  
2. 快表的功耗限制（StrongARM上快表功耗占27%）  

反置页表  
基于hash映射查找对应页表项中的帧号    
1. 进程标识与页号的hash值可能有冲突  
2. 页表项中包括保护位、修改位、访问位和存在位等标识  

#### 段页式存储管理  


#### 虚拟存储  
需求：计算机系统时常出现内存空间不够用  
1. 覆盖：应用程序手动把需要的指令和数据保存在内存中  
2. 交换：操作系统自动把暂时不能执行的程序保存到外存中  
3. 虚拟存储：在有限的内存中，以页为单位自动装入更多更大的程序  


虚拟存储的基本特征：  
不连续性：物理内存分配非连续，虚拟地址空间使用非连续
大用户空间：提供给用户的虚拟内存可大于实际的物理内存    
部分交换：虚拟存储只对部分虚拟地址空间进行调入和调出  

#### 页面置换算法
功能和目标：当出现缺页异常，需调入新页面而内存已满，置换算法选择被置换的物理页面  
设计目标：尽可能减少页面的调入调出次数，把未来不再访问或者短期内不访问的页面调出  
页面锁定  

#### 进程和线程  
定义：进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程  
内存中的进程分为：堆、栈、代码段  
进程包含了正在运行的一个程序的所有状态信息  
1. 代码  
2. 数据  
3. 状态寄存器  
4. 通用寄存器  
5. 进程占用系统资源  
进程的特点：动态性、并发性、独立性、制约性  
进程与程序的联系  
1. 进程是操作系统处于执行状态程序的抽象  
程序 = 文件 （静态的可执行文件）  
进程 = 执行中的程序 = 程序 + 执行状态  
2. 同一个程序的多次执行过程对应为不同进程  
如命令“ls”的多次执行对应多个进程  
3. 进程执行需要的资源  
内存：保存代码和数据  
CPU：执行指令  
进程与程序的区别  
1. 进程是动态的，程序是静态的  
程序是有序代码的集合  
进程是程序的执行，进程有核心态/用户态  
2. 进程是暂时的，程序是永久的  
进程是一个状态变化的过程  
程序可长久保存  
3. 进程与程序的组成不同  
进程的组成包括程序、数据和进程控制块  

#### 进程控制块（PCB，Process Control Block）  
PCB是进程存在的唯一标志  
每个进程都在操作系统中有一个对应的PCB  

进程的创建  
生成该进程的PCB  
进程终止  
回收它的PCB  
进程的组织管理  
通过对PCB的组织管理来实现  


#### PCB包含哪些信息？
进程标识信息、处理机现场保存、进程控制信息（调度和状态信息、进程间通信信息、存储管理信息、进程所用资源、有关数据结构连接信息）  
进程控制块的组织：链表（就绪链表、阻塞链表）、索引表（就绪索引表、阻塞索引表）  

#### 进程的生命周期划分  
进程创建  
进程执行  
进程等待  
进程抢占  
进程唤醒  
进程结束  

创建、退出、就绪、等待、运行、就绪挂起、等待挂起  
挂起是把一个进程转到外存  

#### 线程的概念  
为什么引入线程？  
进程之间如何通信，共享数据？  
系统开销较大：创建、结束、切换  
在进程内部增加一类实体，满足以下特性：  
1. 实体之间可以并发执行  
2. 实体之间共享相同的地址空间  
这种实体就是线程  
线程是进程的一部分，描述指令流执行状态，它是进程中的指令执行的最小单元，是CPU调度的基本单位  
线程 = 进程 - 共享资源  
线程的优点：  
1. 一个进程中可以同时存在多个线程  
2. 各个线程之间可以并发地执行  
3. 各个线程之间可以共享地址空间和文件等资源  
缺点：  
一个线程崩溃，会导致其所属进程的所有线程崩溃  

#### 进程和线程的比较：  
1. 进程是资源分配的单位，线程是CPU调度的单位  
2. 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈  
3. 线程具有就绪、等待和运行三种基本状态和状态间转换关系  
4. 线程能减少并发执行的时间和空间开销  
线程的创建时间比进程短  
线程的终止时间比进程短  
同一进程内的线程切换时间比进程短  
由于同意进程的各线程间共享内存和文件资源，可不通过内核直接进行通信  

线程的三种实现方式：  
1. 用户线程：在用户空间实现  
2. 内核线程：在内核中实现  
3. 轻量级进程：在内核中实现，支持用户线程  

##### 进程切换（上下文切换）  
暂停当前运行进程，从运行状态编程其他状态  
调度另一个进程从就绪状态变成运行状态  

##### 进程切换的要求  
切换前，保存进程上下文  
切换后，恢复进程上下文  
快速切换  

##### 进程生命周期的信息  
寄存器  
CPU状态  
内存地址空间  

##### 进程创建  
windows：creatprocess  
unix：fork()  

##### 进程加载  
exec()

##### 进程等待与退出  
wait()、sleep()
exit()

系统加载的时候：CPU加电，然后启动BIOS里面的程序，BIOS里的程序运行之后  
从硬盘上去加载引导扇区，引导扇区加载完了之后，是BootLoader，再到内核映像  
内核做了一系列工作之后，现在到我们的应用程序。
用户通过exec()去加载可执行文件  

#### 处理机调度  
进程切换：CPU资源的当前占用者切换  
1. 保存当前进程在PCB中的执行上下文（CPU状态）  
2. 恢复下一个进程的执行上下文  

概念：
1. 从就绪队列中挑选下一个占用CPU运行的进程  
2. 从多个可用CPU中挑选就绪进程可使用的CPU资源  

调度程序：挑选就绪进程的内核函数  
调度策略：依据什么原则挑选进程/线程？  
调度时机：什么时候进行调度？  
1. 进程从运行状态切换到等待状态  
2. 进程被终结了  

非抢占系统：  
当前进程主动放弃CPU时  

可抢占系统：  
1. 中断请求被服务例程相应完成时  
2. 当前进程被抢占  
    a. 进程时间片用完  
    b. 进程从等待切换到就绪  

评价调度算法的准则：  
时间片的大小  
CPU的使用率  
吞吐量  
周转时间  
等待时间  
响应时间  


什么是更快？  
传输文件时的高带宽，是调度算法的高吞吐量  
方法：  
减少开销（操作系统的开销、上下文切换）  
系统资源的高效利用（CPU、I/O设备）

打游戏的是低延迟，是调度算法的低响应延迟  
方法：  
减少每个进程的等待时间  


#### 调度算法  
##### 先来先服务算法  
FCFS
依据进程进入就绪状态的先后顺序排列  

优点：  
简单  

缺点：  
执行时间长的进程排在前面的时候，后面的执行时间短的进程等待的时间长。周转时间变长了。  
1. 平均等待时间波动较大  
2. I/O资源和CPU资源的利用率较低  

##### 短进程优先算法  
SPN  
考虑了进程执行的时间，就绪队列中执行时间最短进程占用CPU进入运行状态
对就绪队列中的进程按预期执行时间进行从小到大排序  

变种：短剩余时间优先算法（SRT），就绪队列中执行时间短的进程允许中断当前执行时间长的进程，抢占执行。  

缺点：  
可能导致饥饿，连续的短进程流会使常金成无法获得CPU资源  
需要预知进程的执行时间（简单的解决方法：询问用户（用户欺骗就杀死相应进程），用户不知道怎么办？？（用历史的执行时间来预估未来的执行时间））  

##### 最高响应比优先算法  
HRRN  
选择就绪队列中响应比R值最高的进程  
R = (w + s) / s       
w:等待时间  
s:执行时间  
在短进程优先算法的基础上改进  
不可抢占  
关注进程的等待时间  

##### 时间片轮转算法  
RR
时间片：分配处理及资源的基本时间单元  
算法思路：时间片结束时，按FCFS算法切换到下一个就绪进程  
每隔n-1个时间片进程执行一个时间片q  

RR算法开销：  
额外的上下文切换  
时间片太大：  
等待时间过长  
极限情况退化成FCFS 
时间片太小：  
反应迅速，但产生大量上下文切换  
大量上下文切换开销影响到系统吞吐量  
时间片长度选择目标：  
选择一个合适的时间片长度  
经验规则：维持上下文切换开销处于1%以内  

平均等待时间比较稳定  
FCFS，最差最优等待时间相差很大  

##### 多级队列调度算法
MQ  
就绪队列被划分为多个独立的子队列（如：前台进行交互，后台进行批处理）  

每个队列拥有自己的调度策略（如：前台RR，后台FCFS）  

队列间的调度  
1. 固定优先级（先处理前台，后处理后台，可能导致饥饿）  
2. 时间片轮转（每个队列都得到一个确定的能够调度其进程的CPU总时间，80%CPU时间前台，20%CPU时间后台）  

##### 多级反馈队列算法
MLFQ  
进程可在不同队列间移动的多级队列算法  
1. 时间片大小随优先级别增加而增加  
2. 进程在当前的时间片没有完成，则降到下一个优先级  

特征：CPU密集型进程的优先级下降的很快  
I/O密集型进程停留在优先级  

##### 公平共享调度算法  
FSS
控制用户对系统资源的访问  
一些用户组比其他用户组更重要  
保证不重要的组无法垄断资源  
未使用的资源按比例分配  
没有达到资源使用率目标的组获得更高的优先级  

总结：  
先来先服务：不公平，平均等待时间较差  
短进程优先：不公平，平均周转时间最小，需要精确预测执行时间，可能导致饥饿  
最高响应时间比优先：基于SPN调度，不可抢占  
时间片轮转：公平，但平均等待时间较差  
多级反馈队列：多种算法的集成    
公平共享调度：公平是第一要素  

#### 实时调度  
实时操作系统：正确性依赖于时间和功能两方面的操作系统  
性能指标：时间约束的及时性、速度和平均性能相对不重要  
特性：时间约束的可预测性  

##### 速率单调调度算法（RM）  
1. 通过周期安排优先级  
2. 周期越短优先级越高  
3. 执行周期最短的任务  

##### 最早截止时间优先算法（EDF）  
1. 执行时间最早的优先级越高  
2. 执行截止时间最早的任务

#### 多处理器调度  
多个处理机组成的一个多处理机系统  
处理机间可负载共享  
#### 对称对处理机调度  

#### 对称多处理器的进程分配  
静态进程分配  
1. 进程从开始到结束都被分配到一个固定的处理机上执行  
2. 每个处理机有自己的就绪队列  
3. 调度开销小  
4. 各处理机可能忙闲不均  

动态进程分配  
1. 进程在执行中可分配到任意空闲处理机执行  
2. 所有处理机共享一个公共的就绪队列  
3. 调度开销大  
4. 各处理机的负载是均衡的  

#### 优先级反置
操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象  
基于优先级的可抢占调度算法存在优先级反置  

#### 优先级继承  
占用资源的低优先级进程继承申请资源的高优先级进程的优先级  
只有占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级  

#### 优先级天花板协议  
占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同  
不管是否发生等待，都提升占用资源进程的优先级  
优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会阻塞  


#### 同步与互斥  
##### 并发进程的正确性  
独立进程  
1. 不和其他进程共享资源或状态  
2. 确定性->输入状态决定结果  
3. 可重现->能够重现起始条件  
4. 调度顺序不重要  

并发进程  
1. 在多个进程间有资源共享  
2. 不确定性  
3. 不可重现性  

并发进程的正确性  
1. 执行过程是不确定性和不可重现的    
2. 程序错误可能是间歇性发生的  

进程并发执行的好处  
进程需要与计算机中的其他进程和设备进行协作  
1. 共享资源  
多个用户使用同一台计算机  
银行账号存款余额在多台ATM机操作  
机器人上的嵌入式系统协调手臂和手的操作  
2. 加速  
I/O操作和CPU计算可以重叠（并行）  
程序可划分成多个模块在多个处理器上并行执行  
3. 模块化  
将大程序分解成小程序  
以编译为例，gcc会调用cpp，cc1，cc2，as，ld  
使系统易于复用和扩展  

#### 原子操作  
原子操作是指一次不存在任何中断或失败的操作  
1. 要么操作成功完成  
2. 或者操作没有执行  
3. 不会出现部分执行的状态  

操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作  


#### 临界区  
进程中访问临界资源的一段需要互斥执行的代码  

访问规则：  
1. 空闲则入：没有进程在临界区，任何进程可进入  
2. 忙则等待：有进程在临界区时，其他进程均不能进入临界区  
3. 有限等待：等待进入临界区的进程不能无限期等待  
4. 让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）  

临界区的实现方法：
1. 禁用中断（仅限于单处理器）  
没有中断，没有上下文切换，因此没有并发  

缺点：禁用中断后，进程无法被停止、临界区可能很长

2. 软件方法（复杂）  
Peterson算法  
Dekkers算法  
Eisenberg和McGuire  

缺点：复杂、需要忙等待  

3. 更高级的抽象方法  
###### 硬件提供了一些同步原语  
###### 锁
锁是一种高级的同步抽象方法  
1. 互斥可以使用锁来实现  
2. 需要硬件支持  

锁是一个抽象的数据结构  
1. 一个二进制变量（锁定/解锁）  
2. Lock::Acquire() 锁被释放前一直等待，然后得到锁  
3. Lock::Release() 释放锁，唤醒任何等待的进程

###### 原子操作指令（单处理器或多处理器均可）  
现代CPU体系结构都提供一些特殊的原子操作指令  
1. 测试和置位指令（TS指令）  
从内存单元中读取值  
测试该值是否为1（返回真或假）  
内存单元值设置为1  
2. 交换指令  
交换内存中的两个值  


利用TS指令实现自旋锁（spinlock）  

原子操作指令的特征：  
优点：  
1. 适用于单处理器或者共享主存的多处理器中任意数量的进程同步  
2. 简单并且容易证明  
3. 支持多临界区  

缺点：  
1. 忙等待销号处理器时间  
2. 可能导致饥饿  
进程离开临界区时有多个等待进程的情况  
3. 死锁  
拥有临界区的低优先进程  
请求访问临界区的高优先级进程获得处理器并等待临界区  

#### 进入区  
检查可否进入临界区的一段代码  
如可进入，设置相应“正在访问临界区”标志  
#### 退出区  
清楚正在访问临界区的标志  
#### 剩余区  
代码中的剩余部分  

#### 信号量  
并发问题：多线程并发导致资源竞争  
同步概念：
1. 协调多线程对共享数据的访问  
2. 任何时刻只能有一个线程执行临界区代码  
确保同步正确的方法：  
1. 底层硬件支持  
2. 高层次的编程抽象  


信号量是操作系统提供的一种协调共享资源访问的方法  
1. 软件同步是平等线程间的一种同步协商机制  
2. OS是管理者，地位高于进程  
3. 用信号量表示系统资源的数量  

由Dijkstra在20世纪60年代提出  

信号量是一种抽象的数据类型  

信号量和PV操作


P是当资源小于0时  
V是当资源小于等于0时  



