<!-- GFM-TOC -->
* [2019年3月](#2019年3月)
    * [11.Monday.Sunny](#11.Monday.Sunny)
<!-- GFM-TOC -->


# 2019年3月

## 11.Monday.Sunny
1. Linux和Windows一样，没有孰高孰低之分，只是两种不同的操作系统而已。    
2. 图形化界面之于命令行，是人们对更高级、更方便的工具的追求的必然结果。
3. Linux C++ 也不一定就是后台开发，Windows C++ 也不一定就是客户端开发；所谓的服务器与客户端是个相对的概念，即谁给谁提供服务，提供服务的我们认为是服务端（后台），被服务的我们认为是客户端（前台）。
  
## UNIX 与 Linux [Linux与Unix之差异在哪？](https://baijiahao.baidu.com/s?id=1591814171811153796&wfr=spider&for=pc)  
在计算机时代，相当一部分的人错误地认为 Unix 和 Linux 操作系统是一样的。然而，事实恰好相反。让我们仔细看看。
#### 什么是 Unix?
在 IT 领域，以操作系统而为人所知的 Unix，是 1969 年 AT&T 公司在美国新泽西所开发的(目前它的商标权由国际开放标准组织所拥有)。大多数的操作系统都受到了 Unix 的启发，而 Unix 也受到了未完成的 Multics 系统的启发。Unix 的另一版本是来自贝尔实验室的 Play 9。
#### Unix 被用于哪里?
作为一个操作系统，Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。
#### Unix 系统的特点
1. 支持多任务
2. 相比 Multics 操作更加简单
3. 所有数据以纯文本形式存储
4. 采用单一根文件的树状存储
5. 能够同时访问多用户账户  
#### Unix 操作系统的组成
a) 单核操作系统，负责低级操作以及由用户发起的操作，内核之间的通信通过系统调用进行。
b) 系统工具
c) 其他应用程序
#### 什么是 Linux?
这是一个基于 Unix 操作系统原理的开源操作系统。正如开源的含义一样，它是一个可以自由下载的系统。它也可以通过编辑、添加及扩充其源代码而定制该系统。这是它最大的好处之一，而不像今天的其它操作系统(Windows、Mac OS X 等)需要付费。Unix 系统不是创建新系统的唯一模版，另外一个重要的因素是 MINIX 系统，不像 Linus，此版本被其缔造者(Andrew Tanenbaum)用于商业系统。
Linux 由 Linus Torvalds 开发于 1991 年，这是一个其作为个人兴趣的操作系统。为什么 Linux 借鉴 Unix 的一个主要原因是因为其简洁性。Linux 第一个官方版本(0.01)发布于 1991 年 9 月 17 日。虽然这个系统并不是很完美和完善，但 Linus 对它产生很大的兴趣，并在几天内，Linus 发出了一些关于 Linux 源代码扩展以及其他想法的电子邮件。
#### Linux 的特点
Linux 的基石是 Unix 内核，其基于 Unix 的基本特点以及 POSIX 和单独的 UNIX 规范标准。看起来，该操作系统官方名字取自于 Linus，其中其操作系统名称的尾部的 “x” 和 Unix 系统相联系。
#### 主要功能
1. 同时运行多任务(多任务)
2. 程序可以包含一个或多个进程(多用途系统)，且每个进程可能有一个或多个线程。
3. 多用户，因此它可以运行多个用户程序。
4. 个人帐户受适当授权的保护。
5. 因此账户准确地定义了系统控制权。  
企鹅 Tux 的 Logo 作者是 Larry Ewing，他选择这个企鹅作为他的开源 Linux 操作系统的吉祥物。Linux Torvalds 最初提出这个新的操作系统的名字为 “Freax” ，即为 “自由(free)” + “奇异(freak)” + x(UNIX 系统)的结合字，而不像存放它的首个版本的 FTP 服务器上所起的名字(Linux)。  


#### UNIX和Linux的授权方式不同
从根本上讲，UNIX和Linux最大的区别在于前者是对源代码实行知识产权保护的传统商业软件。在UNIX发展初期，当时的UNIX版权归AT&T公司所有。为了促进UNIX的发展，AT&T公司以低廉甚至免费的许可将UNIX源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩充和改进，形成了所谓的UNIX衍生版，这些衍生版反过来也促进了UNIX的发展。  

后来AT&T公司意识到了UNIX的商业价值，不再将UNIX源码授权给学术机构，并对之前的UNIX及其变种声明了版权权利。这对UNIX的发展产生了很大的影响。在随后的几十年中，UNIX的发展经常伴随着产权纠纷。对于UNIX来说，应用比较广泛的发行版大多数都是商业公司来维护，例如OracleSolaris、IBMAIX以及HPUX等。  

Linux从一开始就是遵循GNU通用公共许可协议(GNU General Publice License，简称GNU GPL或GPL)，GPL授予程序接受人以任何目的运行此程序的自由、再发行复制件的自由以及改进程序、并公开发布改进的自由。因此，任何个人或者公司都可以在GPL的允许范围之内对Linux的代码进行修改，并且进行再发行。另外，Linux可以运用于任何的领域，包括商业应用。  

#### UNIX和Linux不存在技术上面的传承关系  

尽管Linux的设计思想受到了MINIX的很大影响，但是这种影响并不是技术上的，更多的是理念上的。Linux并没有使用UNIX的一行代码，是Linux完全从头构建的操作系统。因此，Linux不是UNIX的衍生版，它是一个全新的操作系统。   

#### UNIX和Linux对于硬件的要求不同  

由于长期以来，UNIX都是由一些大型的公司在维护，因此UNIX通常与这些公司所生产的硬件相配套。例如，Oracle Solaris在很长的一段时间都只有SPARC平台的版本，HP-UX可以在HP的PA-RISC处理器、Intel的Itanium处理器的电脑上运行、IBMAlX则运行在IBM的Power PC架构之上。正因为如此，很大程度上限制了UNIX的广泛应用。  

#### UNIX是一个功能非常全面的操作系统，在某些方面超越Linux
经过30多年的不断发展，UNIX的一些基本技术已变得十分成熟，有的已成为各类操作系统的常用技术。无数的实践表明，UNIX是能达到大型主机可靠性要求的少数操作系统之一。目前许多UNIX大型：主机和服务器在国内外的大型企业中每天24小时不间断地运行。例如，不少大企业或政府部门，将其整个企业/部门信息系统建立并运行在以UNIX为主服务器的客户机/服务器架构上。  

Linux成功地模仿了UNIX系统和功能，它能够在普通PC计算机上实现全部的UNIX特性，具有多任务、多用户的能力。更为重要的是，Linux是一个开放源代码的产品，任何个人或者公司都可以修改Linux内核的源代码，实现或者增强自己想要的功能。  

实际上，UNIX与Linux的区别还有很多，例如，UNIX拥有强大的网络功能，作为互联网基石的TCP/IP协议就是在UNIX系统上开发和发展起来的。UNIX多用于超级计算机、小型机或者工作站，这些技术的成长与UNIX是分不开的。UNIX是历史上影响最大、最成功的操作系统。  

#### 联系
Linux的起源可以追溯到古老的UNIX系统。正因为受到了UNIX的影响，才诞生了Linux。Linux继承了UNIX的许多优良传统，例如强大的网络功能、完善的命令以及良好的健壮性与稳定性。无论是从外观上，还是从功能上，UNIX与Linux都是非常相似的。例如，UNIX的大部分常用命令都可以在Linux中找到相应的命令。  

另外，Linux同样是一个遵循POSIX标准的操作系统。因此，许多UNIX上面的应用可以非常方便地移植到Linux上面。同样，Linux上面的应用也可以非常方便地转移到UNIX上面。  



#### 操作系统
1. 操作系统结构
2. 中断及系统调用
3. 内存管理
4. 进程和线程
5. 处理机调度
6. 同步互斥
7. 文件系统
8. I/O子系统

#### 什么是操作系统？
没有公认的精确的定义  
操作系统是一个控制程序  
操作系统是一个资源管理器  
应用程序与硬件之间的中间层  
管理各种计算机软硬件资源  
提供访问计算机软硬件资源的高效手段  
解决资源访问冲突，确保资源公平使用  

操作系统内核：系统调用接口、硬件抽象层  
内核的特征：并发、共享、虚拟、异步  
并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度  
共享：宏观上“同时”访问，微观上互斥共享  
虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务  
异步：  
1. 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知  
2. 只要运行环境相同，OS需要保证程序运行的结果也要相同  

操作系统的结构：  
分层结构、微内核结构（尽可能将内核功能移到用户空间）、外核结构（虚拟机管理器VMM）  
我们现在用的是分层和微内核的混合体  


#### x86的中断处理  
中断：  
外部中断（串口、硬盘、网卡、时钟）硬中断  
软件产生的中断（软中断）（用户程序通过系统调用访问OS内核服务） 

异常：  
除0错误  

每个中断或者异常与一个中断服务例程关联，其中断关系存储在中断描述表中  
（ISR，Interrupt Service Routian）  

#### 操作系统实验
http://os.cs.tsinghua.edu.cn/oscourse/OS2020spring  

#### 操作系统的内存管理方式   
希望内存管理抽象（逻辑地址空间）、保护（独立地址空间）、共享（访问相同内存）、虚拟化（更大的地址空间）
操作系统中采用的内存管理方式：  
1. 重定位(段地址+偏移量)  
2. 分段（数据段、代码段、堆栈三个相对独立的部分）    
3. 分页（）  
4. 虚拟存储（目前多数系统如Linux采用按需页式虚拟存储）  

实现高度依赖硬件  
1. 与计算机存储架构紧耦合  
2. MMU（内存管理单元）：处理CPU存储访问请求的硬件  


#### 地址空间 & 地址生成  
地址的定义：物理地址空间、逻辑地址空间  
逻辑地址的生成：编译、汇编、链接、程序加载（重定位）  
地址生成时机和限制：  
编译时（1.假设起始地址已知  2.如果起始地址改变，必须重新编译）  
加载时（1.如编译时起始位置未知，编译器需生成可重定位的代码  2.加载时，生成绝对地址）  
执行时（1.执行时代码可移动  2.需地址转换（映射）硬件支持）  

#### 连续内存分配  
内存碎片  
动态分配：  
1. 最先匹配  
原理：分配n个字节，使用第一个可用的空间比n大的空闲块。  
空闲分区列表按地址顺序排序。  
分配过程时，搜索一个合适的分区。  
释放分区时，检查是否可与临近的空闲分区合并  
优点：简单、在高地址空间有大块的空闲分区  
缺点：外部碎片、分配大块时较慢  

2. 最佳匹配  
原理：分配n字节分区时，查找并使用不小于n的最小空闲分区。比它大的最少的  
空闲分区列表按大小排序  
分配时，查找一个合适的分区  
释放时，查找并且合并临近的空闲分区（如果没有找到）  
优点：大部分分配的尺寸较小时，效果很好（可避免大的空闲分区被拆分，可减少外部碎片的大小，相对简单）  
缺点：外部碎片、释放分区较慢、容易产生很多无用的小碎片  

3. 最差匹配  
碎片整理  
原理：分配n字节，使用尺寸不同小于n的最大空闲分区  
空闲分区列表按大到小排序  
分配时，选最大的分区  
释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序  
优点：中等大小的分配较多时，效果最好。避免出现太多的小碎片。  
缺点：释放分区较慢、外部碎片、容易破坏大的空闲分区，因此后续难以分配大的分区  


连续内存分配  
给进程分配一块不小于指定大小的连续的物理内存区域  
内存碎片  
空闲内存不能被利用  
外部碎片  
分配单元之间未被使用的内存  
内部碎片  
分配单元内部的未被使用的内存  
取决于分配单元大小是否要取整  

（分配空闲分区按什么排序、分配时的查找开销、释放时的合并开销、合并后放回到空闲分区列表找合适位置的开销）

碎片整理：通过调整进程占用的分区位置来减少或避免分区碎片  
紧凑：通过移动分配给进程的内存分区，以合并外部碎片（条件：所有的应用程序可动态重定位，需要解决的问题：什么时候移动？开销？）    
分区对换：通过抢占并回收处于等待状态进程的分区，以增大可用内存空间。（换入换出的开销很大）  

#### 实例：伙伴系统
二分法  
大了切一半  
释放后，连续的内存地址能合并成2的幂则合并  

#### 非连续内存分配  


#### 段式存储管理  
进程的段地址空间由多个段组成  
主代码段  
子模块代码段  
公用库代码段  
堆栈段  
堆数据  
初始化数据段  
符号表  
等  

#### 页式存储管理  
页帧（物理页面）：把物理地址空间划分为大小相同的基本分配单位（2的n次方，如512,4096,8192）  
内存物理地址的表示：二元组（f,o），f——帧号（F位，共有2的F次方个帧），o——帧内偏移（S位，每帧有2的S次方字节）  
物理地址 = f * 2^S + o  

页面（逻辑页面）：把逻辑地址空间也划分为相同大小的基本分配单位（帧和页的大小必须是相同的）  
页内偏移 = 帧内偏移  
通常：页号大小 ≠ 帧号大小  


页面到页帧：  
1. 逻辑地址到物理地址的转换  
2. 页表（保存了逻辑地址到物理地址之间的映射关系）  
3. MMU/TLB  

##### 页表  
每个进程都有一个页表  
1. 每个页面对应一个页表项  
2. 随进程运行状态而动态变化  
3. 页表基址寄存器（PTBR:Page Table Base Register）  

页式存储管理机制的性能问题  
1. 访问一个内存单元需要2次内存访问  
2. 第一次访问：获取页表项  
3. 第二次访问：访问数据  

页表大小问题：  
1. 页表可能非常大  
2. 64位机器如果每页1024个字节，那么一个页表的大小会是多大？  

如何处理？  
1. 缓存（快表，TLB）  
2. 间接访问（多级页表，建立页表“树”，减少每级页表的长度）（反置页表，将进程的ID也考虑进去做hash）  

大地址空间问题  
对于大地址空间（64-bits）系统，多级页表变得繁琐  
比如：5级页表  
逻辑（虚拟）地址空间增长速度快于物理地址空间  

页寄存器和反置业面的思路  
1. 不让页表与逻辑地址空间的大小相对应  
2. 让页表与物理地址空间的大小相对应  

页寄存器中的地址转换  
CPU生成的逻辑地址如何找到对应的物理地址？  
对逻辑地址进行hash映射，以减少搜索范围  
需要解决可能的冲突  

用快表缓存页表项后的页寄存器搜索步骤  
1. 对逻辑地址进行hash变换
2. 在快表中查找对应页表项  
3. 有冲突时遍历冲突项链表  
4. 查找失败时，产生异常  

快表的限制：  
1. 快表的容量限制  
2. 快表的功耗限制（StrongARM上快表功耗占27%）  

反置页表  
基于hash映射查找对应页表项中的帧号    
1. 进程标识与页号的hash值可能有冲突  
2. 页表项中包括保护位、修改位、访问位和存在位等标识  

#### 段页式存储管理  


#### 虚拟存储  
需求：计算机系统时常出现内存空间不够用  
1. 覆盖：应用程序手动把需要的指令和数据保存在内存中  
2. 交换：操作系统自动把暂时不能执行的程序保存到外存中  
3. 虚拟存储：在有限的内存中，以页为单位自动装入更多更大的程序  


虚拟存储的基本特征：  
不连续性：物理内存分配非连续，虚拟地址空间使用非连续
大用户空间：提供给用户的虚拟内存可大于实际的物理内存    
部分交换：虚拟存储只对部分虚拟地址空间进行调入和调出  

#### 页面置换算法
功能和目标：当出现缺页异常，需调入新页面而内存已满，置换算法选择被置换的物理页面  
设计目标：尽可能减少页面的调入调出次数，把未来不再访问或者短期内不访问的页面调出  
页面锁定  



#### 进程和线程  
定义：进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程  
内存中的进程分为：堆、栈、代码段  
进程包含了正在运行的一个程序的所有状态信息  
1. 代码  
2. 数据  
3. 状态寄存器  
4. 通用寄存器  
5. 进程占用系统资源  
进程的特点：动态性、并发性、独立性、制约性  
进程与程序的联系  
1. 进程是操作系统处于执行状态程序的抽象  
程序 = 文件 （静态的可执行文件）  
进程 = 执行中的程序 = 程序 + 执行状态  
2. 同一个程序的多次执行过程对应为不同进程  
如命令“ls”的多次执行对应多个进程  
3. 进程执行需要的资源  
内存：保存代码和数据  
CPU：执行指令  
进程与程序的区别  
1. 进程是动态的，程序是静态的  
程序是有序代码的集合  
进程是程序的执行，进程有核心态/用户态  
2. 进程是暂时的，程序是永久的  
进程是一个状态变化的过程  
程序可长久保存  
3. 进程与程序的组成不同  
进程的组成包括程序、数据和进程控制块  

#### 进程控制块（PCB，Process Control Block）  
PCB是进程存在的唯一标志  
每个进程都在操作系统中有一个对应的PCB  

进程的创建  
生成该进程的PCB  
进程终止  
回收它的PCB  
进程的组织管理  
通过对PCB的组织管理来实现  


#### PCB包含哪些信息？
进程标识信息、处理机现场保存、进程控制信息（调度和状态信息、进程间通信信息、存储管理信息、进程所用资源、有关数据结构连接信息）  
进程控制块的组织：链表（就绪链表、阻塞链表）、索引表（就绪索引表、阻塞索引表）  

#### 进程的生命周期划分  
进程创建  
进程执行  
进程等待  
进程抢占  
进程唤醒  
进程结束  


创建、退出、就绪、等待、运行、就绪挂起、等待挂起  
挂起是把一个进程转到外存  

#### 线程的概念  
为什么引入线程？  
进程之间如何通信，共享数据？  
系统开销较大：创建、结束、切换  
在进程内部增加一类实体，满足以下特性：  
1. 实体之间可以并发执行  
2. 实体之间共享相同的地址空间  
这种实体就是线程  
线程是进程的一部分，描述指令流执行状态，它是进程中的指令执行的最小单元，是CPU调度的基本单位  
线程 = 进程 - 共享资源  
线程的优点：  
1. 一个进程中可以同时存在多个线程  
2. 各个线程之间可以并发地执行  
3. 各个线程之间可以共享地址空间和文件等资源  
缺点：  
一个线程崩溃，会导致其所属进程的所有线程崩溃  

进程和线程的比较：  
1. 进程是资源分配的单位，线程是CPU调度的单位  
2. 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈  
3. 线程具有就绪、等待和运行三种基本状态和状态间转换关系  
4. 线程能减少并发执行的时间和空间开销  
线程的创建时间比进程短  
线程的终止时间比进程短  
同一进程内的线程切换时间比进程短  
由于同意进程的各线程间共享内存和文件资源，可不通过内核直接进行通信  

线程的三种实现方式：  
1. 用户线程：在用户空间实现  
2. 内核线程：在内核中实现  
3. 轻量级进程：在内核中实现，支持用户线程  

##### 进程切换（上下文切换）  
暂停当前运行进程，从运行状态编程其他状态  
调度另一个进程从就绪状态变成运行状态  

##### 进程切换的要求  
切换前，保存进程上下文  
切换后，恢复进程上下文  
快速切换  

##### 进程生命周期的信息  
寄存器  
CPU状态  
内存地址空间  

##### 进程创建  
windows：creatprocess  
unix：fork/exec  

##### 进程加载  


##### 进程等待与退出  