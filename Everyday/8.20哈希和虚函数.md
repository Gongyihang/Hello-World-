哈希冲突怎么解决？  哈希表：可以根据关键字快速查询数据的数据结构    
1. 开放地址法：  
线性探测（按顺序往后加一个单位，直到没有冲突）  
平方探测（在原来值的基础上加一个平方单位，随之是2的平方、3的平方，直到没有冲突）  
伪随机探测（在原来的基础上，通过随机函数生成一个数，加上去直到不发生冲突）   

2. 链式地址法  
对于相同的值用链表进行链接，优点：处理冲突简单，无堆积，删除操作易于实现。缺点，指针占用空间大，空间浪费。   

3. 建立公共溢出区  
存储所有哈希冲突的数据  

4. 再哈希法，对冲突的哈希值进行哈希处理，直到没有哈希冲突  

#### 什么是虚函数？  
简单来说，用virtual关键字修饰的成员函数，就是虚函数。  

1. 定义一个函数为虚函数，不代表函数为不被实现的函数。

2. 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

3. 定义一个函数为纯虚函数，才代表函数没有被实现。

4. 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
虚函数只能借助于指针或者引用来达到多态的效果。   

“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的

#### 什么是纯虚函数？  
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”  
virtual void funtion1()=0  
1. 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。　　
2. 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。　　
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。   
定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。  

抽象类就是类里面有纯虚函数的类  



#### 正确理解函数的重载、重复、隐藏？  
##### 重载的特征：  
　　１、处在相同的空间中，即相同的范围内。  
　　２、函数名相同。  
　　３、参数不同，即参数个数不同，或相同位置的参数类型不同。  
　　４、virtual关键字对是否够成重载无任何影响。    
##### 隐藏规则：
　　１、派生类的函数跟基类的函数同名，但是参数不同，此时，不论有没有virtual关键字，基类函数将被隐藏。  
　　２、派生类的函数跟基类的函数同名，且参数也样，但基类没有virtual关键字，此时基类函数也将被隐藏。    

##### 对覆盖规则的定义如下:  
　　(1)不同的范围（分别位于派生类与基类）;  
　　(2)函数名字相同;  
　　(3)参数相同;  
　　(4)基类函数必须有virtual 关键字.  

##### 菱形继承  
假如类A和类B各自从类X派生，且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据。   
虚继承将共同基类设置为虚基类，从不同途径继承来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。从而解决了二义性问题、节省了内存，避免了数据不一致的问题。  

虚函数是如何创建的、如何继承的？  

类的实例化对象在数据段只存虚函数表指针和非全局静态的成员变量，虚函数实体和非静态函数存在代码区。

虚函数是如何访问的？  


#### 虚函数是怎么实现的  
对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。  

#### 指针常量和常量指针  
1. 指针常量：指针的指向不容改变，但是指向的地址里的内容可以改变。  
```cpp
int a, b;
int * const p = &a;//指针常量
*p = 9;//成功
p = &b;//失败
```

2. 常量指针：指针的指向的地址中的内容不容改变，但是指针的指向可以改变。
```cpp
int a, b;
const int *p = &a;//指针常量
*p = 9;//失败
p = &b;//成功
```

3. 指向常量的指针常量的写法  
```cpp
const int * const b = &a;//指针的指向和指向地址的内容均不可改变。
```