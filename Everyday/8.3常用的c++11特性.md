#### 请阐述一下常用的C++11特性有哪些？  
1. 关键字方面：  
auto、nullptr、for循环  
2. STL容器方面：  
array、forward_list、unorder_map、unorder_set  
3. 多线程方面：  
std::thread、std::atomic、condition_variable  
4. 智能指针内存管理  
std::shared_ptr、std::weak_ptr  
5. 其他  
std::function、std::bind封装可执行对象  
lamda表达式  

STL六大组件
容器（Container）、算法（Algorithm）、迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配置器（allocator）

[C++11常用特性总结](https://www.cnblogs.com/chengjundu/p/10893702.html)  


结构体变量可以作为函数的参数和返回值。作为函数的实参时，可以实现函数的传值调用。当使用结构体变量作为函数的形参时，实参也应该是结构体变量名以实现传值调用，实参将拷贝副本给形参，在被调用函数中改变形参值对于调用函数中的实参没有影响。

```cpp
有以下程序：
# include <stdio.h>
typedef struct { int b，p；} A；
void f(A c) /* 注意：c是结构变量名*/
{ int j；
　c.b ＋＝1；c.p＋＝2；
}

main()
{ int i；
　A a＝{1,2}；
　f(a)；
　printf("%d，%d\n"，a.b，a.p)；
}
程序运行后的输出结果是(　　)。

A) 2,4

B) 1,2

C) 1,4

D) 2,3

参考答案：B
```


#### 请用简单的语言告诉我C++ 是什么？
C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!

#### C和C++的区别？  
c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。  

#### STL库用过吗，常用的STL容器有哪些，算法用过哪几个？  
STL包括两个部分：
容器和算法（重要的还有融合这两者的迭代器）
容器，即存放数据的地方（比如array等）
在STL中，容器分为两类：序列式容器和关联式容器。  
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；  
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。  
下面各选取一个作为说明。  
#### 这里涉及vector的扩容机制
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。  
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。  
算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。  
迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

#### 底层实现原理
STL 众多容器中，vector 是最常用的容器之一，其底层所采用的数据结构非常简单，就只是一段连续的线性内存空间。  
通过分析 vector 容器的源代码不难发现，它就是使用 3 个迭代器（可以理解成指针）来表示的：  
```cpp
//_Alloc 表示内存分配器，此参数几乎不需要我们关心
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector{
    ...
protected:
    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
};
```
其中，_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。
![](http://c.biancheng.net/uploads/allimg/191212/2-191212123P2Q5.gif)  

图 1 演示了以上这 3 个迭代器分别指向的位置。
如图 1 所示，通过这 3 个迭代器，就可以表示出一个已容纳 2 个元素，容量为 5 的 vector 容器。

在此基础上，将 3 个迭代器两两结合，还可以表达不同的含义，例如：  
_Myfirst 和 _Mylast 可以用来表示 vector 容器中目前已被使用的内存空间；  
_Mylast 和 _Myend 可以用来表示 vector 容器目前空闲的内存空间；  
_Myfirst 和 _Myend 可以用表示 vector 容器的容量。  
对于空的 vector 容器，由于没有任何元素的空间分配，因此 _Myfirst、_Mylast 和 _Myend 均为 null。  
通过灵活运用这 3 个迭代器，vector 容器可以轻松的实现诸如首尾标识、大小、容器、空容器判断等几乎所有的功能，比如：  
```cpp
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector{
public：
    iterator begin() {return _Myfirst;}
    iterator end() {return _Mylast;}
    size_type size() const {return size_type(end() - begin());}
    size_type capacity() const {return size_type(_Myend - begin());}
    bool empty() const {return begin() == end();}
    reference operator[] (size_type n) {return *(begin() + n);}
    reference front() { return *begin();}
    reference back() {return *(end()-1);}
    ...
};
```
vector扩大容量的本质
另外需要指明的是，当 vector 的大小和容量相等（size==capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。  
vector 容器扩容的过程需要经历以下 3 步：
完全弃用现有的内存空间，重新申请更大的内存空间；  
将旧内存空间中的数据，按原有顺序移动到新的内存空间中；  
最后将旧的内存空间释放。  
这也就解释了，为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效的原因。  

由此可见，vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity>=size），以便后期使用。  
vector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。  

使用reserve来避免不必要的重新分配（vector）  
reserve可以强迫容器把它的容量变为至少是n，前提是n不小于当前的大小。  

# C++的三大特性
即面向对象的三大特性，封装继承多态。
![](https://iknow-pic.cdn.bcebos.com/5366d0160924ab189ad11b2036fae6cd7a890be5?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)
#### 封装
所谓封装就是将某些东西包装盒隐藏起来，让外界无法直接使用，只能通过某些特定的方式才能访问。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。  

例如，下例中时一个动物类，我们把数据和功能封装起来。　
```cpp
class Animal
{
public: //这就是公共成员,外部的接口
    void SetAnimalName(string strname);
    void ShowAnimalName();
private: //这是私有成员，外部是无法访问到的
    string m_strName;
};
```

#### 继承
继承是面向对象的一个重要概念，如果一个类B继承自另一个类A，就把这个类B称为“A的子类”，而把A称为“B的父类”。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重新某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。  
继承是指一个对象直接使用另一个对象的属性和方法，事实上我们遇到的很多事物都有继承的含义，例如，若把动物看做一个实体，他可以分成很多个子实体，如：猫、狗、鸡等等，这些字实体都具有动物的特性，因此，动物是它们的“父亲”，而这些子实体则是动物的“孩子”。   

#### 多态  
多态可以使我们以相同的方式处理不同类型的对象，我们可以使用一段代码处理不同类型的对象，只要他们继承/实现了相同的类型。这样我们没有必要为每一种类型的对象编写相同的逻辑，极大的提高了代码的重用。其实，用简单的一句话来形容就是：多态性，允许将子类类型的指针赋值给父类类型的指针，多态性在C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。  


#### sort中的排序算法  
毫无疑问是用到了快速排序，但不仅仅只用了快速排序，还结合了插入排序和堆排序。  
STL的sort算法，数据量大时采用QuickSort快排算法，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用Insertion Sort插入排序。如果递归层次过深，还会改用HeapSort堆排序。  
因为堆排序是时间复杂度恒定为nlogn。

有个东西叫主定理……可以证明如下形式的递归函数![](https://www.zhihu.com/equation?tex=f%28n%29%5Cin2f%5Cleft%28%5Cfrac%7Bn%7D%7B2%7D%5Cright%29%2B%5Cmathrm%7B%5CTheta%7D%28n%29)满足渐进![](https://www.zhihu.com/equation?tex=f%28n%29%5Cin%5CTheta%28n%5Clog+n%29)。这是最佳分割的情形。  
![](https://pic4.zhimg.com/80/v2-318c6eead066aa028df487303f616228_720w.jpg?source=1940ef5c)  

#### 二维数组按行遍历效率高。  
1. cpu高速缓存  
缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。
2. 分页调度  
分页调度：物理内存是以页的方式进行划分的，当一个二维数组很大是如 int[128][1024],假设一页的内存为4096个字节，而每一行正好占据内存的一页，如果以列的形式进行遍历，就会发生128*1024次的页面调度，而如果以行遍历则只有128次页面调度，而页面调度是有时间消耗的，因而调度次数越多，遍历的时间就越长。

