#### 引用和指针  
引用被称为变量的别名，它不能脱离被引用对象独立存在。  
实际上，引用本身是一个变量，只不过这个变量的定义和使用与普通变量有显著的不同。  
1. 引用变量在功能上等于一个指针常量，即一旦指向某一个单元就不能在指向别处。  
2. 在底层，引用变量由指针按照指针常量的方式实现。  


2. 高级语言层面引用与指针常量的关系  
1.引用和指针，在内存中都是占用4个字节（32bits系统中）的存储空间。指针和引用存放的都是被引用对象的地址，都必须在定义的同时进行初始化。  
2.指针常量本身（以p为例）允许寻址，即&p返回指针常量（常变量）本身的地址，被引用对象用*p表示；引用变量本身（以r为例）不允许寻址，&r返回的是被引用对象的地址，而不是变量r的地址（r的地址由编译器掌握，程序员无法直接对它进行存取），被引用对象直接用r表示。  
3.凡是使用了引用变量的代码，都可以转换成使用指针常量的对应形式的代码，只不过书写形式上要繁琐一些。反过来，由于对引用变量使用方式上的限制，使用指针常量能够实现的功能，却不一定能够用引用来实现。  

4.一些其他不同：    
引用使用时无需解引用(*)，指针需要解引用；  
“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；    
引用不能为空，指针可以为空；    
指针和引用的自增(++)运算意义不一样；引用自增被引用对象的值，指针自增内存地址。  


指针和引用在传参上有什么不同：  
指针传递本质上是值传递的方式  
引用传递的过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（int &a的形式）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。


深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。  
浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。  

