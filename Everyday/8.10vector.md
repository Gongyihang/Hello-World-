#### vector的底层实现原理是什么样的？  
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。   


迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

#### 怎么扩容？     
vector扩大容量的本质
另外需要指明的是，当 vector 的大小和容量相等（size==capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。  
vector 容器扩容的过程需要经历以下 3 步：
完全弃用现有的内存空间，重新申请更大的内存空间；  
将旧内存空间中的数据，按原有顺序移动到新的内存空间中；  
最后将旧的内存空间释放。  
这也就解释了，为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效的原因。  

由此可见，vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity>=size），以便后期使用。  
vector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。  

使用reserve来避免不必要的重新分配（vector）  
reserve可以强迫容器把它的容量变为至少是n，前提是n不小于当前的大小。 

#### 插入时间复杂度是多少？  
最普遍的情况下，当扩容因子为2时，最好的评价时间复杂度为2N，发生在N等于2的n次幂时，最差为3N，发生在N等于2的n次幂加1时。  
S = 1 + k + k^2 + k^3 + k^4  + …… +  k^(logkN) = (N-1)/(K-1)  

显然，也就意味着扩容因子K越大，额外的消耗越小。总消耗为N+(N-1)/(K-1) 。当K大于1时，K越大总消耗越小。  

那么，那个最佳的数是多少呢？

继续刚才的分析，我们希望的是，上几次的空间，存在被下一次扩容时利用的可能性。

也就是 X(n-2) + X(n-1) >= X(n)，显然我们也希望时间上也要更好，即X(n-2) + X(n-1) = X(n)

即：1，2，3，5，8，13，21，34，55 。。。。

是不是很熟悉。。。是的，这就是我们的斐波那契数列。。。

那么当N趋于无限大时，取极限，最佳的扩容因子也就是那个最美的数，黄金分割率，1.618。
#### 扩容有影响吗？  




#### STL库用过吗，常用的STL容器有哪些，算法用过哪几个？  
STL包括两个部分：
容器和算法（重要的还有融合这两者的迭代器）
容器，即存放数据的地方（比如array等）
在STL中，容器分为两类：序列式容器和关联式容器。  
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；  
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。  